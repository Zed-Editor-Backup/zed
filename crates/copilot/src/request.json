{
  "intent": true,
  "n": 1,
  "stream": true,
  "temperature": 0.1,
  "model": "claude-3.5-sonnet",
  "messages": [
    {
      "role": "system",
      "content": "You are an AI assistant integrated into a code editor. You have the programming ability of an expert programmer who takes pride in writing high-quality code and is driven to the point of obsession about solving problems effectively. Your goal is to do one of the following two things:\n\n1. Help users answer questions and perform tasks related to their codebase.\n2. Answer general-purpose questions unrelated to their particular codebase.\n\nIt will be up to you to decide which of these you are doing based on what the user has told you. When unclear, ask clarifying questions to understand the user's intent before proceeding.\n\nYou should only perform actions that modify the user's system if explicitly requested by the user:\n- If the user asks a question about how to accomplish a task, provide guidance or information, and use read-only tools (e.g., search) to assist. You may suggest potential actions, but do not directly modify the userâ€™s system without explicit instruction.\n- If the user clearly requests that you perform an action, carry out the action directly without explaining why you are doing so.\n\nEditing code:\n- Make sure to take previous edits into account.\n- The edits you perform might lead to errors or warnings. At the end of your changes, check whether you introduced any problems, and fix them before providing a summary of the changes you made.\n- You may only attempt to fix these up to 3 times. If you have tried 3 times to fix them, and there are still problems remaining, you must not continue trying to fix them, and must instead tell the user that there are problems remaining - and ask if the user would like you to attempt to solve them further.\n- Do not fix errors unrelated to your changes unless the user explicitly asks you to do so.\n- Prefer to move files over recreating them. The move can be followed by minor edits if required.\n\nTool use:\n- Make sure to adhere to the tools schema.\n- Provide every required argument.\n- DO NOT use tools to access items that are already available in the context section.\n- Use only the tools that are currently available.\n- DO NOT use a tool that is not available just because it appears in the conversation. This means the user turned it off.\n\nResponding:\n- Be concise and direct in your responses.\n- Never apologize or thank the user.\n- Don't comment that you have just realized or understood something.\n- When you are going to make a tool call, tersely explain your reasoning for choosing to use that tool, with no flourishes or commentary beyond that information.\n    For example, rather than saying \"You're absolutely right! Thank you for providing that context. Now I understand that we're missing a dependency, and I need to add it:\" say \"I'll add that missing dependency:\" instead.\n- Also, don't restate what a tool call is about to do (or just did).\n    For example, don't say \"Now I'm going to check diagnostics to see if there are any warnings or errors,\" followed by running a tool which checks diagnostics and reports warnings or errors; instead, just request the tool call without saying anything.\n- All tool results are provided to you automatically, so DO NOT thank the user when this happens.\n\nThe user has opened a project that contains the following root directories/files. Whenever you specify a path in the project, it must be a relative path which begins with one of these root directories/files:\n\n- `auk` (absolute path: `/Users/maxdeviant/projects/auk`)\n"
    },
    { "role": "user", "content": "Create an a.txt file containing a haiku" }
  ],
  "tools": [
    {
      "type": "function",
      "function": {
        "name": "delete_path",
        "description": "Deletes the file or directory (and the directory's contents, recursively) at the specified path in the project, and returns confirmation of the deletion.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "DeletePathToolInput",
          "type": "object",
          "required": ["path"],
          "properties": {
            "path": {
              "description": "The path of the file or directory to delete.\n\n<example> If the project has the following files:\n\n- directory1/a/something.txt - directory2/a/things.txt - directory3/a/other.txt\n\nYou can delete the first file by providing a path of \"directory1/a/something.txt\" </example>",
              "type": "string"
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "move_path",
        "description": "Moves or rename a file or directory in the project, and returns confirmation that the move succeeded.\nIf the source and destination directories are the same, but the filename is different, this performs\na rename. Otherwise, it performs a move.\n\nThis tool should be used when it's desirable to move or rename a file or directory without changing its contents at all.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "MovePathToolInput",
          "type": "object",
          "required": ["destination_path", "source_path"],
          "properties": {
            "destination_path": {
              "description": "The destination path where the file or directory should be moved/renamed to. If the paths are the same except for the filename, then this will be a rename.\n\n<example> To move \"directory1/a/something.txt\" to \"directory2/b/renamed.txt\", provide a destination_path of \"directory2/b/renamed.txt\" </example>",
              "type": "string"
            },
            "source_path": {
              "description": "The source path of the file or directory to move/rename.\n\n<example> If the project has the following files:\n\n- directory1/a/something.txt - directory2/a/things.txt - directory3/a/other.txt\n\nYou can move the first file by providing a source_path of \"directory1/a/something.txt\" </example>",
              "type": "string"
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "now",
        "description": "Returns the current datetime in RFC 3339 format. Only use this tool when the user specifically asks for it or the current task would benefit from knowing the current datetime.",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "NowToolInput",
          "type": "object",
          "required": ["timezone"],
          "properties": {
            "timezone": {
              "description": "The timezone to use for the datetime.",
              "allOf": [{ "$ref": "#/definitions/Timezone" }]
            }
          },
          "definitions": {
            "Timezone": {
              "oneOf": [
                { "description": "Use UTC for the datetime.", "type": "string", "enum": ["utc"] },
                { "description": "Use local time for the datetime.", "type": "string", "enum": ["local"] }
              ]
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "read_file",
        "description": "Reads the content of the given file in the project.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "ReadFileToolInput",
          "type": "object",
          "required": ["path"],
          "properties": {
            "end_line": {
              "description": "Optional line number to end reading on (1-based index)",
              "default": null,
              "type": ["integer", "null"],
              "format": "uint",
              "minimum": 0.0
            },
            "path": {
              "description": "The relative path of the file to read.\n\nThis path should never be absolute, and the first component of the path should always be a root directory in a project.\n\n<example> If the project has the following root directories:\n\n- directory1 - directory2\n\nIf you wanna access `file.txt` in `directory1`, you should use the path `directory1/file.txt`. If you wanna access `file.txt` in `directory2`, you should use the path `directory2/file.txt`. </example>",
              "type": "string"
            },
            "start_line": {
              "description": "Optional line number to start reading on (1-based index)",
              "default": null,
              "type": ["integer", "null"],
              "format": "uint",
              "minimum": 0.0
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "symbol_info",
        "description": "Gives detailed information about code symbols in your project such as variables, functions, classes, interface, traits, and other programming constructs, using the editor's integrated Language Server Protocol (LSP) servers.\n\nThis tool is the preferred way to do things like:\n* Find out where a code symbol is first declared (or first defined - that is, assigned)\n* Find all the places where a code symbol is referenced\n* Find the type definition for a code symbol\n* Find a code symbol's implementation\n\nThis tool gives more reliable answers than things like regex searches, because it can account for relevant semantics like aliases. It should be used over textual search tools (e.g. regex) when searching for information about code symbols that this tool supports directly.\n\nThis tool should not be used when you need to search for something that is not a code symbol.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "SymbolInfoToolInput",
          "type": "object",
          "required": ["command", "context_after_symbol", "context_before_symbol", "path", "symbol"],
          "properties": {
            "command": {
              "description": "The information to get about the symbol.",
              "allOf": [{ "$ref": "#/definitions/Info" }]
            },
            "context_after_symbol": {
              "description": "The text that comes immediately after the symbol in the file.",
              "type": "string"
            },
            "context_before_symbol": {
              "description": "The text that comes immediately before the symbol in the file.",
              "type": "string"
            },
            "path": {
              "description": "The relative path to the file containing the symbol.\n\nWARNING: you MUST start this path with one of the project's root directories.",
              "type": "string"
            },
            "symbol": {
              "description": "The symbol name. This text must appear in the file right between `context_before_symbol` and `context_after_symbol`.\n\nThe file must contain exactly one occurrence of `context_before_symbol` followed by `symbol` followed by `context_after_symbol`. If the file contains zero occurrences, or if it contains more than one occurrence, the tool will fail, so it is absolutely critical that you verify ahead of time that the string is unique. You can search the file's contents to verify this ahead of time.\n\nTo make the string more likely to be unique, include a minimum of 1 line of context before the symbol, as well as a minimum of 1 line of context after the symbol. If these lines of context are not enough to obtain a string that appears only once in the file, then double the number of context lines until the string becomes unique. (Start with 1 line before and 1 line after though, because too much context is needlessly costly.)\n\nDo not alter the context lines of code in any way, and make sure to preserve all whitespace and indentation for all lines of code. The combined string must be exactly as it appears in the file, or else this tool call will fail.",
              "type": "string"
            }
          },
          "definitions": {
            "Info": {
              "oneOf": [
                {
                  "description": "Get the symbol's definition (where it's first assigned, even if it's declared elsewhere)",
                  "type": "string",
                  "enum": ["definition"]
                },
                {
                  "description": "Get the symbol's declaration (where it's first declared)",
                  "type": "string",
                  "enum": ["declaration"]
                },
                { "description": "Get the symbol's implementation", "type": "string", "enum": ["implementation"] },
                { "description": "Get the symbol's type definition", "type": "string", "enum": ["type_definition"] },
                {
                  "description": "Find all references to the symbol in the project",
                  "type": "string",
                  "enum": ["references"]
                }
              ]
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "copy_path",
        "description": "Copies a file or directory in the project, and returns confirmation that the copy succeeded.\nDirectory contents will be copied recursively (like `cp -r`).\n\nThis tool should be used when it's desirable to create a copy of a file or directory without modifying the original.\nIt's much more efficient than doing this by separately reading and then writing the file or directory's contents,\nso this tool should be preferred over that approach whenever copying is the goal.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "CopyPathToolInput",
          "type": "object",
          "required": ["destination_path", "source_path"],
          "properties": {
            "destination_path": {
              "description": "The destination path where the file or directory should be copied to.\n\n<example> To copy \"directory1/a/something.txt\" to \"directory2/b/copy.txt\", provide a destination_path of \"directory2/b/copy.txt\" </example>",
              "type": "string"
            },
            "source_path": {
              "description": "The source path of the file or directory to copy. If a directory is specified, its contents will be copied recursively (like `cp -r`).\n\n<example> If the project has the following files:\n\n- directory1/a/something.txt - directory2/a/things.txt - directory3/a/other.txt\n\nYou can copy the first file by providing a source_path of \"directory1/a/something.txt\" </example>",
              "type": "string"
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "diagnostics",
        "description": "Get errors and warnings for the project or a specific file.\n\nThis tool can be invoked after a series of edits to determine if further edits are necessary, or if the user asks to fix errors or warnings in their codebase.\n\nWhen a path is provided, shows all diagnostics for that specific file.\nWhen no path is provided, shows a summary of error and warning counts for all files in the project.\n\n<example>\nTo get diagnostics for a specific file:\n{\n    \"path\": \"src/main.rs\"\n}\n\nTo get a project-wide diagnostic summary:\n{}\n</example>\n\nIMPORTANT: When you're done making changes, you **MUST** get the **project** diagnostics (input: `{}`) at the end of your edits so you can fix any problems you might have introduced. **DO NOT** tell the user you're done before doing this!\n\nYou may only attempt to fix these up to 3 times. If you have tried 3 times to fix them, and there are still problems remaining, you must not continue trying to fix them, and must instead tell the user that there are problems remaining - and ask if the user would like you to attempt to solve them further.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "DiagnosticsToolInput",
          "type": "object",
          "properties": {
            "path": {
              "description": "The path to get diagnostics for. If not provided, returns a project-wide summary.\n\nThis path should never be absolute, and the first component of the path should always be a root directory in a project.\n\n<example> If the project has the following root directories:\n\n- lorem - ipsum\n\nIf you wanna access diagnostics for `dolor.txt` in `ipsum`, you should use the path `ipsum/dolor.txt`. </example>",
              "type": ["string", "null"]
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "thinking",
        "description": "A tool for thinking through problems, brainstorming ideas, or planning without executing any actions. Use this tool when you need to work through complex problems, develop strategies, or outline approaches before taking action.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "ThinkingToolInput",
          "type": "object",
          "required": ["content"],
          "properties": {
            "content": {
              "description": "Content to think about. This should be a description of what to think about or a problem to solve.",
              "type": "string"
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "fetch",
        "description": "Fetches a URL and returns the content as Markdown.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "FetchToolInput",
          "type": "object",
          "required": ["url"],
          "properties": { "url": { "description": "The URL to fetch.", "type": "string" } }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "find_replace_file",
        "description": "Find one unique part of a file in the project and replace that text with new text.\n\nThis tool is the preferred way to make edits to files. If you have multiple edits to make, including edits across multiple files, then make a plan to respond with a single message containing multiple calls to this tool - one call for each find/replace operation.\n\nYou should use this tool when you want to edit a subset of a file's contents, but not the entire file. You should not use this tool when you want to replace the entire contents of a file with completely different contents. You also should not use this tool when you want to move or rename a file. You absolutely must NEVER use this tool to create new files from scratch. If you ever consider using this tool to create a new file from scratch, for any reason, instead you must reconsider and choose a different approach.\n\nDO NOT call this tool until the code to be edited appears in the conversation! You must use another tool to read the file's contents into the conversation, or ask the user to add it to context first.\n\nNever call this tool with identical \"find\" and \"replace\" strings. Instead, stop and think about what you actually want to do.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "FindReplaceFileToolInput",
          "type": "object",
          "required": ["display_description", "find", "path", "replace"],
          "properties": {
            "display_description": {
              "description": "A user-friendly markdown description of what's being replaced. This will be shown in the UI.\n\n<example>Fix API endpoint URLs</example> <example>Update copyright year in `page_footer`</example>",
              "type": "string"
            },
            "find": {
              "description": "The unique string to find in the file. This string cannot be empty; if the string is empty, the tool call will fail. Remember, do not use this tool to create new files from scratch, or to overwrite existing files! Use a different approach if you want to do that.\n\nIf this string appears more than once in the file, this tool call will fail, so it is absolutely critical that you verify ahead of time that the string is unique. You can search within the file to verify this.\n\nTo make the string more likely to be unique, include a minimum of 3 lines of context before the string you actually want to find, as well as a minimum of 3 lines of context after the string you want to find. (These lines of context should appear in the `replace` string as well.) If 3 lines of context is not enough to obtain a string that appears only once in the file, then double the number of context lines until the string becomes unique. (Start with 3 lines before and 3 lines after though, because too much context is needlessly costly.)\n\nDo not alter the context lines of code in any way, and make sure to preserve all whitespace and indentation for all lines of code. This string must be exactly as it appears in the file, because this tool will do a literal find/replace, and if even one character in this string is different in any way from how it appears in the file, then the tool call will fail.\n\n<example> If a file contains this code:\n\n```ignore fn check_user_permissions(user_id: &str) -> Result<bool> { // Check if user exists first let user = database.find_user(user_id)?;\n\n// This is the part we want to modify if user.role == \"admin\" { return Ok(true); }\n\n// Check other permissions check_custom_permissions(user_id) } ```\n\nYour find string should include at least 3 lines of context before and after the part you want to change:\n\n```ignore fn check_user_permissions(user_id: &str) -> Result<bool> { // Check if user exists first let user = database.find_user(user_id)?;\n\n// This is the part we want to modify if user.role == \"admin\" { return Ok(true); }\n\n// Check other permissions check_custom_permissions(user_id) } ```\n\nAnd your replace string might look like:\n\n```ignore fn check_user_permissions(user_id: &str) -> Result<bool> { // Check if user exists first let user = database.find_user(user_id)?;\n\n// This is the part we want to modify if user.role == \"admin\" || user.role == \"superuser\" { return Ok(true); }\n\n// Check other permissions check_custom_permissions(user_id) } ``` </example>",
              "type": "string"
            },
            "path": {
              "description": "The path of the file to modify.\n\nWARNING: When specifying which file path need changing, you MUST start each path with one of the project's root directories.\n\nThe following examples assume we have two root directories in the project: - backend - frontend\n\n<example> `backend/src/main.rs`\n\nNotice how the file path starts with root-1. Without that, the path would be ambiguous and the call would fail! </example>\n\n<example> `frontend/db.js` </example>",
              "type": "string"
            },
            "replace": {
              "description": "The string to replace the one unique occurrence of the find string with.",
              "type": "string"
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "batch_tool",
        "description": "Invoke multiple other tool calls either sequentially or concurrently.\n\nThis tool is useful when you need to perform several operations at once, improving efficiency by reducing the number of back-and-forth interactions needed to complete complex tasks.\n\nIf the tool calls are set to be run sequentially, then each tool call within the batch is executed in the order provided. If it's set to run concurrently, then they may run in a different order. Regardless, all tool calls will have the same permissions and context as if they were called individually.\n\nThis tool should never be used to run a total of one tool. Instead, just run that one tool directly. You can run batches within batches if desired, which is a way you can mix concurrent and sequential tool call execution.\n\nWhen it's possible to run tools in a batch, you should run as many as possible in the batch, up to a maximum of 32. For example, don't run multiple consecutive batches of 10 when you could instead run one batch of 30.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "BatchToolInput",
          "type": "object",
          "required": ["invocations"],
          "properties": {
            "invocations": {
              "description": "The tool invocations to run as a batch. These tools will be run either sequentially or concurrently depending on the `run_tools_concurrently` flag.\n\n<example> Basic file operations (concurrent)\n\n```json { \"invocations\": [ { \"name\": \"read_file\", \"input\": { \"path\": \"src/main.rs\" } }, { \"name\": \"list_directory\", \"input\": { \"path\": \"src/lib\" } }, { \"name\": \"regex_search\", \"input\": { \"regex\": \"fn run\\\\(\" } } ], \"run_tools_concurrently\": true } ``` </example>\n\n<example> Multiple find-replace operations on the same file (sequential)\n\n```json { \"invocations\": [ { \"name\": \"find_replace_file\", \"input\": { \"path\": \"src/config.rs\", \"display_description\": \"Update default timeout value\", \"find\": \"pub const DEFAULT_TIMEOUT: u64 = 30;\\n\\npub const MAX_RETRIES: u32 = 3;\\n\\npub const SERVER_URL: &str = \\\"https://api.example.com\\\";\", \"replace\": \"pub const DEFAULT_TIMEOUT: u64 = 60;\\n\\npub const MAX_RETRIES: u32 = 3;\\n\\npub const SERVER_URL: &str = \\\"https://api.example.com\\\";\" } }, { \"name\": \"find_replace_file\", \"input\": { \"path\": \"src/config.rs\", \"display_description\": \"Update API endpoint URL\", \"find\": \"pub const MAX_RETRIES: u32 = 3;\\n\\npub const SERVER_URL: &str = \\\"https://api.example.com\\\";\\n\\npub const API_VERSION: &str = \\\"v1\\\";\", \"replace\": \"pub const MAX_RETRIES: u32 = 3;\\n\\npub const SERVER_URL: &str = \\\"https://api.newdomain.com\\\";\\n\\npub const API_VERSION: &str = \\\"v1\\\";\" } } ], \"run_tools_concurrently\": false } ``` </example>\n\n<example> Searching and analyzing code (concurrent)\n\n```json { \"invocations\": [ { \"name\": \"regex_search\", \"input\": { \"regex\": \"impl Database\" } }, { \"name\": \"path_search\", \"input\": { \"glob\": \"**/*test*.rs\" } } ], \"run_tools_concurrently\": true } ``` </example>\n\n<example> Multi-file refactoring (concurrent)\n\n```json { \"invocations\": [ { \"name\": \"find_replace_file\", \"input\": { \"path\": \"src/models/user.rs\", \"display_description\": \"Add email field to User struct\", \"find\": \"pub struct User {\\n    pub id: u64,\\n    pub username: String,\\n    pub created_at: DateTime<Utc>,\\n}\", \"replace\": \"pub struct User {\\n    pub id: u64,\\n    pub username: String,\\n    pub email: String,\\n    pub created_at: DateTime<Utc>,\\n}\" } }, { \"name\": \"find_replace_file\", \"input\": { \"path\": \"src/db/queries.rs\", \"display_description\": \"Update user insertion query\", \"find\": \"pub async fn insert_user(conn: &mut Connection, user: &User) -> Result<(), DbError> {\\n    conn.execute(\\n        \\\"INSERT INTO users (id, username, created_at) VALUES ($1, $2, $3)\\\",\\n        &[&user.id, &user.username, &user.created_at],\\n    ).await?;\\n    \\n    Ok(())\\n}\", \"replace\": \"pub async fn insert_user(conn: &mut Connection, user: &User) -> Result<(), DbError> {\\n    conn.execute(\\n        \\\"INSERT INTO users (id, username, email, created_at) VALUES ($1, $2, $3, $4)\\\",\\n        &[&user.id, &user.username, &user.email, &user.created_at],\\n    ).await?;\\n    \\n    Ok(())\\n}\" } } ], \"run_tools_concurrently\": true } ``` </example>",
              "type": "array",
              "items": { "$ref": "#/definitions/ToolInvocation" }
            },
            "run_tools_concurrently": {
              "description": "Whether to run the tools in this batch concurrently. If this is false (the default), the tools will run sequentially.",
              "default": false,
              "type": "boolean"
            }
          },
          "definitions": {
            "ToolInvocation": {
              "type": "object",
              "required": ["input", "name"],
              "properties": {
                "input": { "description": "The input to the tool in JSON format" },
                "name": { "description": "The name of the tool to invoke", "type": "string" }
              }
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "code_symbols",
        "description": "Returns either an outline of the public code symbols in the entire project (grouped by file) or else an outline of both the public and private code symbols within a particular file.\n\nWhen a path is provided, this tool returns a hierarchical outline of code symbols for that specific file.\nWhen no path is provided, it returns a list of all public code symbols in the project, organized by file.\n\nYou can also provide an optional regular expression which filters the output by only showing code symbols which match that regex.\n\nResults are paginated with 2000 entries per page. Use the optional 'offset' parameter to request subsequent pages.\n\nMarkdown headings indicate the structure of the output; just like\nwith markdown headings, the more # symbols there are at the beginning of a line,\nthe deeper it is in the hierarchy.\n\nEach code symbol entry ends with a line number or range, which tells you what portion of the\nunderlying source code file corresponds to that part of the outline. You can use\nthat line information with other tools, to strategically read portions of the source code.\n\nFor example, you can use this tool to find a relevant symbol in the project, then get the outline of the file which contains that symbol, then use the line number information from that file's outline to read different sections of that file, without having to read the entire file all at once (which can be slow, or use a lot of tokens).\n\n<example>\n# class Foo [L123-136]\n## method do_something(arg1, arg2) [L124-126]\n## method process_data(data) [L128-135]\n# class Bar [L145-161]\n## method initialize() [L146-149]\n## method update_state(new_state) [L160]\n## private method _validate_state(state) [L161-162]\n</example>\n\nThis example shows how tree-sitter outlines the structure of source code:\n\n1. `class Foo` is defined on lines 123-136\n   - It contains a method `do_something` spanning lines 124-126\n   - It also has a method `process_data` spanning lines 128-135\n\n2. `class Bar` is defined on lines 145-161\n   - It has an `initialize` method spanning lines 146-149\n   - It has an `update_state` method on line 160\n   - It has a private method `_validate_state` spanning lines 161-162\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "CodeSymbolsInput",
          "type": "object",
          "properties": {
            "case_sensitive": {
              "description": "Whether the regex is case-sensitive. Defaults to false (case-insensitive).\n\n<example> Set to `true` to make regex matching case-sensitive. </example>",
              "default": false,
              "type": "boolean"
            },
            "offset": {
              "description": "Optional starting position for paginated results (0-based). When not provided, starts from the beginning.",
              "default": 0,
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "path": {
              "description": "The relative path of the source code file to read and get the symbols for. This tool should only be used on source code files, never on any other type of file.\n\nThis path should never be absolute, and the first component of the path should always be a root directory in a project.\n\nIf no path is specified, this tool returns a flat list of all symbols in the project instead of a hierarchical outline of a specific file.\n\n<example> If the project has the following root directories:\n\n- directory1 - directory2\n\nIf you want to access `file.md` in `directory1`, you should use the path `directory1/file.md`. If you want to access `file.md` in `directory2`, you should use the path `directory2/file.md`. </example>",
              "default": null,
              "type": ["string", "null"]
            },
            "regex": {
              "description": "Optional regex pattern to filter symbols by name. When provided, only symbols whose names match this pattern will be included in the results.\n\n<example> To find only symbols that contain the word \"test\", use the regex pattern \"test\". To find methods that start with \"get_\", use the regex pattern \"^get_\". </example>",
              "default": null,
              "type": ["string", "null"]
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "list_directory",
        "description": "Lists files and directories in a given path.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "ListDirectoryToolInput",
          "type": "object",
          "required": ["path"],
          "properties": {
            "path": {
              "description": "The relative path of the directory to list.\n\nThis path should never be absolute, and the first component of the path should always be a root directory in a project.\n\n<example> If the project has the following root directories:\n\n- directory1 - directory2\n\nYou can list the contents of `directory1` by using the path `directory1`. </example>\n\n<example> If the project has the following root directories:\n\n- foo - bar\n\nIf you wanna list contents in the directory `foo/baz`, you should use the path `foo/baz`. </example>",
              "type": "string"
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "bash",
        "description": "Executes a bash one-liner and returns the combined output.\n\nThis tool spawns a bash process, combines stdout and stderr into one interleaved stream as they are produced (preserving the order of writes), and captures that stream into a string which is returned.\n\nMake sure you use the `cd` parameter to navigate to one of the root directories of the project. NEVER do it as part of the `command` itself, otherwise it will error.\n\nRemember that each invocation of this tool will spawn a new bash process, so you can't rely on any state from previous invocations.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "BashToolInput",
          "type": "object",
          "required": ["cd", "command"],
          "properties": {
            "cd": {
              "description": "Working directory for the command. This must be one of the root directories of the project.",
              "type": "string"
            },
            "command": { "description": "The bash command to execute as a one-liner.", "type": "string" }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "regex_search",
        "description": "Searches the entire project for the given regular expression.\n\nReturns a list of paths that matched the query. For each path, it returns some excerpts of the matched text.\n\nResults are paginated with 20 matches per page. Use the optional 'offset' parameter to request subsequent pages.\n\nThis tool is not aware of semantics and does not use any information from language servers, so it should only be used when no available semantic tool (e.g. one that uses language servers) could fit a particular use case instead.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "RegexSearchToolInput",
          "type": "object",
          "required": ["regex"],
          "properties": {
            "offset": {
              "description": "Optional starting position for paginated results (0-based). When not provided, starts from the beginning.",
              "default": 0,
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "regex": {
              "description": "A regex pattern to search for in the entire project. Note that the regex will be parsed by the Rust `regex` crate.",
              "type": "string"
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "create_file",
        "description": "Creates a new file at the specified path within the project, containing the given text content. Returns confirmation that the file was created.\n\nThis tool is the most efficient way to create new files within the project, so it should always be chosen whenever it's necessary to create a new file in the project with specific text content, or whenever a file in the project needs such a drastic change that you would prefer to replace the entire thing instead of making individual edits. This tool should not be used when making changes to parts of an existing file but not all of it. In those cases, it's better to use another approach to edit the file.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "CreateFileToolInput",
          "type": "object",
          "required": ["contents", "path"],
          "properties": {
            "contents": {
              "description": "The text contents of the file to create.\n\n<example> To create a file with the text \"Hello, World!\", provide contents of \"Hello, World!\" </example>",
              "type": "string"
            },
            "path": {
              "description": "The path where the file should be created.\n\n<example> If the project has the following structure:\n\n- directory1/ - directory2/\n\nYou can create a new file by providing a path of \"directory1/new_file.txt\" </example>",
              "type": "string"
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "path_search",
        "description": "Returns paths in the project which match the given glob.\n\nResults are paginated with 50 matches per page. Use the optional 'offset' parameter to request subsequent pages.\n",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "PathSearchToolInput",
          "type": "object",
          "required": ["glob"],
          "properties": {
            "glob": {
              "description": "The glob to search all project paths for.\n\n<example> If the project has the following root directories:\n\n- directory1/a/something.txt - directory2/a/things.txt - directory3/a/other.txt\n\nYou can get back the first two paths by providing a glob of \"*thing*.txt\" </example>",
              "type": "string"
            },
            "offset": {
              "description": "Optional starting position for paginated results (0-based). When not provided, starts from the beginning.",
              "default": 0,
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "query",
        "description": "Run a read-only SQL query",
        "parameters": { "type": "object", "properties": { "sql": { "type": "string" } } }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "pg-schema",
        "description": "Returns the schema for a Postgres database.",
        "parameters": {
          "type": "object",
          "properties": {
            "mode": { "type": "string", "enum": ["all", "specific"], "description": "Mode of schema retrieval" },
            "tableName": {
              "type": "string",
              "description": "Name of the specific table (required if mode is 'specific')"
            }
          },
          "required": ["mode"],
          "if": { "properties": { "mode": { "const": "specific" } } },
          "then": { "required": ["tableName"] }
        }
      }
    }
  ]
}
